# Neo OSI Backend

Интеллектуальный бэкенд-сервис для AI-ассистента в сфере ЖКХ Казахстана.

## Описание

**Neo OSI Backend** — это ядро интеллектуального ассистента, разработанного для экосистемы **Neo OSI**. Проект представляет собой NestJS-приложение, которое предоставляет мощный API для решения двух ключевых задач:

1.  **"ИИ-Консультант"**: Предоставление точных и контекстуальных ответов на вопросы пользователей, касающиеся законодательства и стандартов в сфере ЖКХ и ОСИ, на основе собственной базы знаний.
2.  **"ИИ-Документы"**: Автоматизация процесса создания юридических и технических документов через интуитивно понятный диалоговый интерфейс.

Система разработана с акцентом на надежность, билингвальную поддержку (RU/KZ) и безопасность, обеспечивая бесшовный пользовательский опыт для фронтенд-приложений.

## Ключевые возможности

-   **Билингвальная поддержка:** Система автоматически определяет язык пользователя (русский, казахский, включая "шала-казахский") и ведет весь диалог на соответствующем языке.

-   **Продвинутый RAG-пайплайн:** Для ответов на вопросы используется многоуровневая система поиска (Retrieval-Augmented Generation), которая обеспечивает высокую точность и минимизирует "галлюцинации":
    -   **Жесткая маршрутизация:** Запросы по ключевым темам (ремонт, ОСИ, взносы) немедленно направляются на поиск в релевантных документах.
    -   **Гибридный поиск:** Комбинация поиска по ключевым словам и семантического (векторного) поиска.
    -   **Расширение контекста:** Система автоматически подгружает весь документ-источник, если найден хотя бы один релевантный фрагмент, чтобы исключить "разорванные" ответы.

-   **Персистентная база знаний:** Векторная база знаний хранится на диске с использованием `HNSWLib`, что обеспечивает быстрый старт приложения и стабильность результатов поиска.

-   **Динамическая генерация документов:** "ИИ-Документы" ведут многошаговый диалог с пользователем, собирают данные и генерируют на их основе готовые `.docx` файлы по шаблонам.

-   **Безопасная аутентификация:** Реализован надежный механизм `accessToken` + `refreshToken` для обеспечения долговременных и безопасных сессий.

-   **Интегрированная бизнес-логика:** Встроенная система подписок, где функция "ИИ-Документы" доступна только пользователям с активным **Премиум-статусом**.

## Технологический стек

-   **Backend:** [NestJS](https://nestjs.com/), [TypeScript](https://www.typescriptlang.org/)
-   **AI & LLM:** [Google Gemini API](https://ai.google.dev/) (модель `gemini-1.5-pro`), [LangChain.js](https://js.langchain.com/)
-   **Базы данных:**
    -   **Основная:** [PostgreSQL](https://www.postgresql.org/) с [TypeORM](https://typeorm.io/)
    -   **Векторная:** [HNSWLib](https://github.com/nmslib/hnswlib) для локального персистентного хранения векторов.
-   **Аутентификация:** [JWT](https://jwt.io/) (`accessToken` + `refreshToken`), [Passport.js](http://www.passportjs.org/)
-   **Генерация документов:** `docxtemplater`
-   **Деплоймент:** [Docker](https://www.docker.com/), [Render](https://render.com/)

## Архитектура системы

Проект построен на модульной архитектуре NestJS. Ключевые компоненты системы взаимодействуют следующим образом:

### 1. RAG-пайплайн (ИИ-Консультант)

Для ответов на вопросы пользователя применяется многоуровневый RAG-пайплайн, разработанный для максимальной точности.

**Пример запроса от пользователя:**
```json
// POST /ai/chat
{
  "prompt": "Что такое текущий ремонт?"
}
```

**Как система обрабатывает этот запрос:**

1.  **Маршрутизация по ключевым словам (`keywordToFileMap`):**
    -   Система находит в запросе ключевое слово "текущий ремонт" и по своим внутренним правилам определяет, что ответ, скорее всего, находится в файлах `СТ РК 2864-2016.pdf.txt` и `Закон... .pdf.txt`. Поиск сужается до этих источников.

2.  **Гибридный поиск в документах (`_getRelevantDocs`):**
    -   **Keyword Search:** Внутри этих двух файлов система ищет фрагменты, где есть точное совпадение "текущий ремонт".
    -   **Vector Search:** Параллельно по всему индексу `HNSWLib` ищется смысловая близость. Результаты, не относящиеся к выбранным файлам, отбрасываются.
    -   **Ранжирование:** Результаты обоих поисков объединяются.

3.  **Расширение контекста (FULL_DOC Expansion):**
    -   Система видит, что был найден релевантный фрагмент из `СТ РК 2864-2016.pdf.txt`.
    -   Она немедленно подгружает в контекст **весь текст** этого стандарта целиком, чтобы гарантировать, что определение не будет "разорвано".

4.  **Генерация ответа (`_generateFinalAnswer`):**
    -   Собранный, объемный контекст и строгие инструкции передаются в Google Gemini для генерации финального ответа, который будет выглядеть примерно так: `"Согласно СТ РК 2864-2016, текущий ремонт здания — это..."`.

### 2. Генерация документов (ИИ-Документы)

Этот процесс управляется `DocumentAiService` и следует логике конечного автомата, где состояние пользователя хранится в БД (`users.doc_chat_...`).

**Пример диалога:**

1.  **Распознавание намерения и выбор шаблона:**
    -   Пользователь отправляет:
        ```json
        // POST /ai/documents
        { "prompt": "Хочу оформить акт приема-передачи" }
        ```
    -   Система определяет намерение, находит наиболее подходящий шаблон и сохраняет его имя (`forma-akta-priyema-peredachi... .docx`) в профиль пользователя.

2.  **Генерация вопросов:**
    -   AI анализирует переменные (`{address}`, `{sender_fio}`) в `.docx` шаблоне и генерирует список вопросов.
    -   Ответ пользователю:
        ```json
        {
          "aiResponse": {
            "action": "collect_data",
            "message": "Для заполнения документа 'Форма акта...' потребуется следующая информация:\n1. Укажите адрес объекта.\n2. ... (и т.д.)"
          }
        }
        ```

3.  **Сбор данных:**
    -   Пользователь отвечает на вопросы. Система парсит ответы и сохраняет их в `user.doc_chat_pending_data` в виде JSON: `{"address": "г. Астана...", "sender_fio": "Иванов И.И."}`.
    -   Каждый раз система задает следующий вопрос, пока не соберет все данные.

4.  **Финальная генерация:**
    -   Когда все данные собраны, они подставляются в `.docx` шаблон.
    -   Сервер возвращает **бинарный файл**, который фронтенд предлагает пользователю скачать.

### 3. Аутентификация

Система использует двух-токенную JWT-схему для безопасности и удобства.

**Пример получения токенов:**
```json
// POST /auth/login
{
  "email": "test@user.com",
  "password": "password123"
}
// Ответ:
{
  "accessToken": "...",  // Живет 1 час, используется для всех запросов
  "refreshToken": "..." // Живет 7 дней, используется только для /auth/refresh
}
```

**Пример обновления токенов:**
```json
// POST /auth/refresh
// Headers: Authorization: Bearer <ВАШ_REFRESH_TOKEN>
// Body: (пустое)
// Ответ:
{
  "accessToken": "НОВЫЙ_...",
  "refreshToken": "НОВЫЙ_..."
}
```

## Настройка и запуск

### 5.1. Предварительные требования

-   [Node.js](https://nodejs.org/) (рекомендуется версия v18.x или выше)
-   [npm](https://www.npmjs.com/) (обычно идет в комплекте с Node.js)
-   [Docker](https://www.docker.com/) и Docker Compose

### 5.2. Установка

1.  **Клонируйте репозиторий:**
    ```bash
    git clone <URL_ВАШЕГО_РЕПОЗИТОРИЯ>
    cd neo-osi-backend
    ```

2.  **Создайте `.env` файл:**
    Скопируйте файл `.env.example` (если он есть) или создайте новый файл `.env` в корневой директории проекта и заполните его по шаблону ниже.

    ```env
    #---------------------------------
    # API Ключи
    #---------------------------------
    # Ключ для доступа к Google Gemini API
    GEMINI_API_KEY=ВАШ_СЕКРЕТНЫЙ_КЛЮЧ_GEMINI
    
    # Секретные ключи для подписи JWT токенов (ДОЛЖНЫ БЫТЬ РАЗНЫМИ И СЛОЖНЫМИ)
    JWT_SECRET=СЕКРЕТНЫЙ_КЛЮЧ_ДЛЯ_ACCESS_TOKEN
    JWT_REFRESH_SECRET=ДРУГОЙ_СЕКРЕТНЫЙ_КЛЮЧ_ДЛЯ_REFRESH_TOKEN
    
    # Время жизни accessToken для тестов (например, 60s, 5m, 1h). 
    # В проде эту строку можно убрать (по умолчанию будет 1 час).
    JWT_ACCESS_TOKEN_EXPIRATION=5m

    #---------------------------------
    # База данных (соответствуют docker-compose.yml)
    #---------------------------------
    DB_HOST=localhost
    DB_PORT=5433
    DB_USERNAME=admin
    DB_PASSWORD=mysecretpassword
    DB_DATABASE=neo_osi_db
    ```

3.  **Установите зависимости:**
    Из-за особенностей зависимостей в `langchain` рекомендуется использовать флаг `--legacy-peer-deps`.
    ```bash
    npm install --legacy-peer-deps
    ```

### 5.3. Работа с базой данных

Проект использует Docker для запуска базы данных PostgreSQL.

1.  **Запустите контейнер с БД:**
    Эта команда запустит базу данных в фоновом режиме.
    ```bash
    docker-compose up -d
    ```

2.  **Примените миграции:**
    После первого запуска базы данных необходимо создать в ней все таблицы.
    ```bash
    npm run migration:run:local
    ```
    Эту команду также нужно выполнять после каждой новой сгенерированной миграции.

### 5.4. Кэширование и индексация (Критически важный шаг)

Для работы "ИИ-Консультанта" необходимо подготовить базу знаний.

1.  **Поместите PDF-файлы:** Убедитесь, что все ваши нормативные документы в формате `.pdf` находятся в папке `knowledge_base`.

2.  **Создайте текстовый кэш:** Этот скрипт извлечет текст из всех PDF и сохранит его в `.pdf-cache`.
    ```bash
    npm run cache
    ```

3.  **Создайте/обновите поисковый индекс:** После запуска приложения оно автоматически создаст или загрузит персистентный поисковый индекс (`HNSWLib`) в папку `.rag-index`.

    **Важно:** Если вы **добавили, изменили или удалили PDF-файлы** и заново запустили `npm run cache`, вам необходимо **удалить старый индекс**, чтобы он пересоздался на основе новых текстов. Просто удалите папку `.rag-index` перед следующим запуском сервера.

### 5.5. Запуск приложения

После выполнения всех шагов можно запустить сервер в режиме разработки:
```bash
npm run start:dev
```
Сервер будет доступен по адресу `http://localhost:3000`. При первом запуске он создаст поисковый индекс, что может занять несколько минут. Последующие запуски будут почти мгновенными.

---

### 6. Полное Описание API Эндпоинтов

Все эндпоинты доступны по базовому URL, который зависит от окружения (например, `http://localhost:3000` для локальной разработки).

Для доступа к защищенным эндпоинтам необходимо в каждом запросе передавать заголовок `Authorization` с `accessToken`:
`Authorization: Bearer <ВАШ_ACCESS_TOKEN>`

### 6.1. Аутентификация (`/auth`)

Этот модуль отвечает за вход, выход и управление сессиями.

---
#### `POST /auth/login`
-   **Описание:** Аутентифицирует пользователя по email и паролю.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "email": "test@example.com",
      "password": "password123"
    }
    ```
-   **Успешный ответ (`201 Created`):** Возвращает пару токенов для управления сессией.
    ```json
    {
      "accessToken": "eyJhbGciOi...", // Короткоживущий, для обычных запросов
      "refreshToken": "eyJhbGciOi..." // Долгоживущий, для обновления сессии
    }
    ```
-   **Ошибка (`401 Unauthorized`):** В случае неверного email или пароля.

---
#### `POST /auth/refresh`
-   **Описание:** Обновляет истекший `accessToken`, используя `refreshToken`.
-   **Аутентификация:** Специальная. Требует `refreshToken` в заголовке.
    -   `Authorization: Bearer <ВАШ_REFRESH_TOKEN>`
-   **Тело запроса (`Body`):** Пустое.
-   **Успешный ответ (`201 Created`):** Возвращает **новую** пару токенов.
    ```json
    {
      "accessToken": "НОВЫЙ_...",
      "refreshToken": "НОВЫЙ_..."
    }
    ```
-   **Ошибка (`401 Unauthorized`):** Если `refreshToken` невалиден или истек.

---
#### `POST /auth/logout`
-   **Описание:** Завершает сессию пользователя, делая `refreshToken` недействительным.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`201 Created`):** Пустое тело.

---
#### `POST /auth/forgot-password`
-   **Описание:** Инициирует процедуру сброса пароля. Отправляет на email пользователя письмо со ссылкой.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "email": "user_who_forgot@example.com"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Если такой пользователь существует, ему будет отправлена ссылка для сброса пароля."
    }
    ```
    *(Ответ всегда одинаковый, чтобы не раскрывать, существует ли email в базе).*

---
#### `POST /auth/reset-password`
-   **Описание:** Устанавливает новый пароль, используя токен из письма.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "token": "токен_из_ссылки_в_письме",
      "password": "МойНовыйНадежныйПароль"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Пароль успешно обновлен."
    }
    ```

---
#### `GET /auth/reset-password`
-   **Описание:** Эндпоинт, на который ведет ссылка из письма. Он **не выполняет действий**, а просто рендерит HTML-страницу для ввода нового пароля.
-   **Аутентификация:** Публичный.
-   **Параметры запроса (`Query Params`):**
    -   `token`: Токен для сброса.
    -   Пример URL: `https://neo-osi-backend.onrender.com/auth/reset-password?token=abcdef123...`

---

### 6.2. Управление пользователями (`/users`)

Этот модуль отвечает за регистрацию и управление данными пользователей.

---
#### `POST /users/register`
-   **Описание:** Создает нового пользователя в системе.
-   **Аутентификация:** Публичный.
-   **Тело запроса (`Body`):**
    ```json
    {
      "email": "newuser@example.com",
      "password": "strongpassword"
    }
    ```
-   **Успешный ответ (`201 Created`):** Возвращает созданный объект пользователя (без пароля).
    ```json
    {
      "id": 123,
      "email": "newuser@example.com",
      "tariff": "Базовый",
      // ... другие поля
    }
    ```

---
#### `GET /users/profile`
-   **Описание:** Возвращает данные профиля текущего аутентифицированного пользователя.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):**
    ```json
    {
      "id": 123,
      "email": "newuser@example.com",
      "fullName": "Иван Иванов",
      "phone": "+77001234567",
      "role": "resident",
      "subscription": {
        "isActive": true,
        "expiresAt": "2025-09-15T12:00:00.000Z"
      }
    }
    ```

---
#### `POST /users/change-password`
-   **Описание:** Позволяет залогиненному пользователю сменить свой пароль.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Тело запроса (`Body`):**
    ```json
    {
      "oldPassword": "мой_старый_пароль",
      "newPassword": "мой_новый_супер_пароль"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Пароль успешно изменен."
    }
    ```

---
#### `POST /users/reset-limit/:email`
-   **Описание:** **(Отладочный эндпоинт)** Сбрасывает лимит генерации документов для пользователя.
-   **Аутентификация:** Публичный (для удобства тестирования).
-   **Параметр URL:** `email` пользователя.
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "message": "Лимит для пользователя newuser@example.com успешно сброшен."
    }
    ```
---

### 6.3. AI-Ассистент (`/ai`)

Этот модуль предоставляет доступ к "ИИ-Консультанту" и "ИИ-Документам".

---
#### `POST /ai/chat`
-   **Описание:** Основной эндпоинт для взаимодействия с **"ИИ-Консультантом"**. Принимает сообщение пользователя и возвращает ответ, сгенерированный на основе базы знаний (RAG).
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Тело запроса (`Body`):**
    ```json
    {
      "prompt": "Что такое ОСИ и чем он отличается от КСК?"
    }
    ```
-   **Успешный ответ (`201 Created`):**
    ```json
    {
      "aiResponse": "Согласно Закону Республики Казахстан... ОСИ — это объединение собственников имущества... КСК — это кооператив собственников квартир..."
    }
    ```
    *(Ответ будет варьироваться в зависимости от вопроса и найденного контекста).*

---
#### `POST /ai/documents`
-   **Описание:** Основной эндпоинт для **"ИИ-Документов"**. Управляет многошаговым диалогом для генерации `.docx` файлов.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Бизнес-логика:** **Доступен только для пользователей с активной Премиум-подпиской.**

-   **Тело запроса (`Body`):**
    ```json
    {
      "prompt": "Текст сообщения от пользователя"
    }
    ```
-   **Возможные ответы:** Ответ сервера зависит от стадии диалога.

    1.  **Если у пользователя нет подписки:**
        ```json
        {
          "aiResponse": {
            "action": "clarification",
            "message": "\"ЖИ-Құжаттар\" — бұл Премиум-мүмкіндік...\n---\n\"ИИ-Документы\" — это Премиум-функция..."
          }
        }
        ```

    2.  **Если пользователь инициирует создание документа:**
        Система предлагает выбрать документ или задает первый вопрос.
        ```json
        {
          "aiResponse": {
            "action": "collect_data",
            "message": "Для заполнения документа 'Форма акта...' потребуется следующая информация:\n1. Укажите адрес объекта..."
          }
        }
        ```

    3.  **Если система не уверена в намерении пользователя:**
        Она задает уточняющий вопрос.
        ```json
        {
          "aiResponse": {
            "action": "clarification",
            "message": "Уточните, какой документ вам нужен?\n\nВот список доступных документов:\n- Форма акта..."
          }
        }
        ```

    4.  **Когда все данные собраны (финальный ответ):**
        -   **Заголовки (`Headers`):**
            -   `Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document`
            -   `Content-Disposition: attachment; filename="имя_документа.docx"`
        -   **Тело ответа (`Body`):** Бинарные данные `.docx` файла.

---

### 6.4. История Чатов (`/chat`)

Этот модуль предоставляет эндпоинты для загрузки истории переписки для разных разделов.

---
#### `GET /chat/history/general`
-   **Описание:** Получает историю переписки для чата **"ИИ-Консультант"**.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):** Массив сообщений.
    ```json
    [
      {
        "role": "user",
        "content": "Что такое кондоминиум?",
        "createdAt": "2025-08-17T12:00:00.000Z"
      },
      {
        "role": "model",
        "content": "Согласно Закону...",
        "createdAt": "2025-08-17T12:00:05.000Z"
      }
    ]
    ```
    *(Если история пуста, сервер автоматически сгенерирует и вернет приветственное сообщение).*

---
#### `GET /chat/history/document`
-   **Описание:** Получает историю переписки для чата **"ИИ-Документы"**.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):** Аналогичен `/chat/history/general`, но для другого типа чата. Также возвращает приветственное сообщение, если история пуста.

---

### 6.5. Финансы (`/finance`)

Этот модуль предоставляет агрегированные финансовые данные. Доступен только для авторизованных пользователей (например, администраторов или бухгалтеров, в зависимости от будущей логики ролей).

---
#### `GET /finance/summary`
-   **Описание:** Возвращает сводный финансовый отчет по всем квартирам в формате JSON.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):**
    ```json
    {
      "total": 155000.75,
      "rows": [
        {
          "apartment": "Кв. 1",
          "lastDate": "2025-08-15",
          "amount": 50000.50
        },
        {
          "apartment": "Кв. 2",
          "lastDate": "2025-08-14",
          "amount": 105000.25
        }
      ]
    }
    ```

---
#### `GET /finance/summary.xlsx`
-   **Описание:** Генерирует и возвращает тот же финансовый отчет в формате `.xlsx` (Microsoft Excel).
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):**
    -   **Заголовки (`Headers`):**
        -   `Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
        -   `Content-Disposition: attachment; filename="finance-summary.xlsx"`
    -   **Тело ответа (`Body`):** Бинарные данные `.xlsx` файла.

---
#### `GET /finance/summary.pdf`
-   **Описание:** Генерирует и возвращает тот же финансовый отчет в формате `.pdf`, включая диаграмму.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Успешный ответ (`200 OK`):**
    -   **Заголовки (`Headers`):**
        -   `Content-Type: application/pdf`
        -   `Content-Disposition: attachment; filename="finance-summary.pdf"`
    -   **Тело ответа (`Body`):** Бинарные данные `.pdf` файла.

---

### 6.6. Подписки (`/subscriptions`)

Этот модуль отвечает за обработку и проверку покупок, совершенных через мобильные платформы.

---
#### `POST /subscriptions/verify-apple`
-   **Описание:** Проверяет чек покупки (receipt) из App Store, чтобы активировать или продлить Премиум-подписку для пользователя.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Тело запроса (`Body`):**
    ```json
    {
      "receipt": "длинная_строка_чека_от_Apple"
    }
    ```
-   **Успешный ответ (`201 Created`):** Возвращает статус успеха и **новый `accessToken`**, в котором уже обновлен тариф пользователя.
    ```json
    {
      "success": true,
      "message": "Премиум-подписка успешно активирована.",
      "accessToken": "НОВЫЙ_ТОКЕН_С_ТАРИФОМ_ПРЕМИУМ_..."
    }
    ```
-   **Ошибка (`400 Bad Request`):** Если чек невалиден.

---

### 6.7. Импорт данных (`/data-import`)

Этот модуль предоставляет административные функции для массовой загрузки данных в систему.

---
#### `POST /data-import/excel`
-   **Описание:** Загружает и обрабатывает `.xlsx` файл для массового импорта данных о жителях, квартирах и балансах.
-   **Аутентификация:** JWT (`accessToken`) требуется.
-   **Тип запроса:** `multipart/form-data`.
    -   **Поле `file`:** Сам `.xlsx` файл.
-   **Параметры запроса (`Query Params`):**
    -   `mode`: Режим импорта. Может быть `append` (добавить данные, по умолчанию) или `replace` (полностью очистить старые данные и загрузить новые).
    -   Пример URL: `/data-import/excel?mode=replace`
-   **Успешный ответ (`201 Created`):** Возвращает статистику по импорту.
    ```json
    {
      "residentsImported": 150,
      "apartmentsImported": 100,
      "balancesImported": 250,
      "errors": [
        "Строка 25: Квартира 'Кв. 999' не найдена."
      ]
    }
    ```
-   **Ошибка (`400 Bad Request`):** Если файл не загружен или имеет неверный формат.

---

## 7. База данных и Миграции

Проект использует **TypeORM** для работы с базой данных PostgreSQL. Все изменения в структуре БД (добавление таблиц, колонок и т.д.) должны производиться через механизм миграций.

### 1. Генерация миграции

После того как вы внесли изменения в файлы сущностей (`.entity.ts`), вам необходимо сгенерировать новый файл миграции.

**Пример:** Вы добавили поле `phone` в `User.entity.ts`.

Выполните в терминале команду:
```bash
npm run migration:generate src/migrations/AddPhoneToUser
```
-   `src/migrations/AddPhoneToUser` — это путь и осмысленное имя для вашей миграции.

В папке `src/migrations` будет создан новый файл (например, `1755...-AddPhoneToUser.ts`) с автоматически сгенерированным SQL-кодом.

### 2. Применение миграций

Чтобы применить все новые, еще не выполненные миграции к вашей **локальной** базе данных, используйте команду:
```bash
npm run migration:run:local
```

### 3. Откат миграций

Если что-то пошло не так, вы можете "откатить" последнюю примененную миграцию:
```bash
npm run typeorm:local -- migration:revert
```

**Важно:** На продакшен-сервере (Render) миграции применяются **автоматически** при каждом деплое благодаря команде `npm run db:migrate:prod`.

---

### 8. Автор и Контакты

Разработка бэкенд-сервиса, включая архитектуру AI-ассистента, RAG-пайплайн и API, выполнена **Мади Жакеновым**.

По вопросам, связанным с проектом, или для предложений о сотрудничестве, пожалуйста, обращайтесь:
-   **Email:** zhakenovmadirus@gmail.com